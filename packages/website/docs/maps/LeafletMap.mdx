---
sidebar_position: 1
title: Leaflet Map
sidebar_label: Leaflet Map ✍️
---
import { PropTable } from '../components/props-table.tsx'
import { DocWrapper } from '../wrappers'
import { LeafletMapPointShape, LeafletMap, Tooltip } from "@volterra/vis";
import { ContextLevel } from '../wrappers/base/types'
import { mapKey } from '@site/src/examples/basic-leaflet-map/key'
import cities from './data/us_cities.json'
import topojson from './data/topojson_overlay.json'
import './styles.css'

export const data = cities.slice(0, 50)
export const defaultProps = () => ({
  name: "LeafletMap",
  height: '300px !important',
  style: `https://api.maptiler.com/maps/positron/style.json?key=${mapKey}`,
  hiddenProps: {
    // for props we want to exclude from code snippets
    className: 'leaflet-doc',
    fitViewPadding: [15,15],
    clusterRadius: 55,
  },
  // define or override variables as they appear in the code snippets
  declarations: {
    style: '\`https://api.maptiler.com/maps/positron/style.json?key=\${key}\`',
  },
  dataType: 'MapDataRecord',
})

export const LeafletDoc = (props) => (
  <DocWrapper {...defaultProps() } {...props}/>
)

export const tooltip = new Tooltip({
  triggers: {
    [LeafletMap.selectors.mapboxglCanvas]: (features) => {
      const name = features[0]?.properties?.name ?? ''
      return `<span>${name}</span>`
    },
  },
})

## Basic Configuration
_LeafletMap_ is a mapping component capable of rendering detailed maps. It doesn't come with preloaded maps,
so you'll need to provide a vector tile source first to make it work. You can use an existing cloud map tile server
(like [MapTiler Cloud](https://www.maptiler.com/cloud/pricing/), which has a free tier) or host your own tiles
(we've successfully used [OpenMapTiles](https://openmaptiles.org) in the past).


Let's assume you've got an API key from MapTiler. You can initialize _LeafletMap_ by providing a `style` URL or
object to it. MapTiler has a few [vector styles](https://www.maptiler.com/maps/) available by default, but you can
also create your own. Don't forget to set the
[attribution](https://documentation.maptiler.com/hc/en-us/articles/4405445885457-How-to-add-MapTiler-attribution-to-a-map)
properly.

<LeafletDoc
  showContext={ContextLevel.Minimal}
  attribution={[
    '<a href="https://www.maptiler.com/copyright/" target="_blank">MapTiler</a>',
    `<a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap contributors</a>`
  ]}
  imports={{ './key': ['key'] }}
  style/>

## Map Data
_LeafletMap_ can plot an array of points provided to the component. The corresponding data objects can be in an
arbitrary format, but they need to have properties storing the latitude and longitude values. A minimum viable datatype
of the data objects looks like:

```ts
type MapPoint = {
  latitude: number;
  longitude: number;
}
```
You can provide alternative `pointLatitude` and `pointLongitude` accessor functions in your _LeafletMap_ configuration.

Close points will automatically cluster and uncluster as you zoom in or out. When you click on a cluster, the map will
smoothly zoom into a cluster (if map zoom is too far) or expand it showing the contained points.

<LeafletDoc data={data}/>

## Points
### Point Color
You can set custom color to the points by using the `pointColor` property, which accepts either a constant CSS color string
or an accessor function. The default point color comes from the `--vis-map-point-default-fill-color` CSS variable.
<LeafletDoc data={data} height={400} pointColor='#FFD651' />

### Point Shape
_LeafletMap_ supports 4 different point shapes: circle, square, triangle and ring. You can set the
shape by using the `pointShape` property. It accepts a `LeafletMapPointShape` enum, a string, or an accessor function
returning either of them.
<LeafletDoc data={data} height={400} pointShape={LeafletMapPointShape.Triangle}/>

### Point Radius
Point radius can be set by providing a constant value or a function to the `pointRadius` property.
<LeafletDoc data={data} height={400} pointRadius={(d) => (Math.sqrt(d.population) / 250) || 10}/>

### Point Labels
Point can have two kinds of labels: central and bottom. The label at the center of the point can be set by using
the `pointLabel` property. This label will fit into the point, so it is supposed to be short.
<LeafletDoc
  data={data}
  height={300}
  pointRadius={(d) => (Math.sqrt(d.population) / 100) || 10}
  pointLabel={d => d.point_count ?? `${(d.population / 1000000).toFixed(1)}M`}
/>

####
The bottom label is configurable via the `pointBottomLabel` property. Both label properties can accept an accessor
function as their value. In the example below we set `pointBottomLabel` to `d => d.id`.
<LeafletDoc data={data.slice(0, 20)} height={200} pointBottomLabel={(d) => d.city}/>

### Point as a Pie or Donut
If you're using `LeafletMapPointShape.Circle` or `LeafletMapPointShape.Ring` as a point shape, and your points have multiple
values of the same kind associated with them, you can show the distribution of those values on a tiny pie / donut diagram.

Let's say we want to show city population by age, and our data point looks like:
```ts
type MapPoint = {
  ...
  age0_18: number;
  age19_64: number;
  age65plus: number;
}
```

You can use the `valuesMap` property to define the color and custom CSS class for the corresponding pie / donut segments:
```ts
const valuesMap = {
  age0_18: { color: '#0085FF' },
  age19_64: { color: '#41A4FF' },
  age65plus: { color: '#8BC7FF' },
}
```

<LeafletDoc
  data={data.slice(0, 20)}
  height={400}
  pointBottomLabel={(d) => d.city}
  pointRadius={(d) => (Math.sqrt(d.population) / 150) || 10}
  pointRingWidth={10}
  valuesMap={{
    age0_18: { color: '#0085FF' },
    age19_64: { color: '#41A4FF' },
    age65plus: { color: '#8BC7FF' },
  }}
/>


## Clusters

### Cluster Ring Width
You can make the cluster ring thinner or thicker with the `clusterRingWidth` property.
<LeafletDoc data={data} clusterRingWidth={3}/>

### Expand on Click
If you don't want clusters to expand on a click, you can set `clusterExpandOnClick` to `false`.
<LeafletDoc data={data} pointColor='#286e47' clusterExpandOnClick={false}/>

## TopoJSON Overlay
_LeafletMap_ can also display a topojson overlay on top of the base map. It's configurable via the `topoJSONLayer`
config property. The configuration object for the overlay consists of several properties:

```js
topoJSONLayer: {
  /* Your `TopoJSON.Topology` object. Default: `undefined` */
  sources: TopoJSON.Topology;
  /* Name of the feature collection to be rendered. Default: `undefined` */
  featureName: string;
  /* Fill color property name. Default: `undefined` */
  fillProperty: string;
  /* Fill opacity. Default: `0.6` */
  fillOpacity: number;
  /* Stroke color property name. Default: `undefined` */
  strokeProperty: string;
  /* Stroke opacity. Default: `0.8` */
  strokeOpacity: number;
  /* Stroke width. Default: `2` */
  strokeWidth: number;
}
```

Let's say your Topojson looks like:
```js
const topojson = {
    "type": "Topology",
    "arcs": [...],
    "objects": {
        "countries": {
            "type": "GeometryCollection",
            "geometries": [
                {
                    "arcs": [...],
                    "type": "MultiPolygon",
                    "properties": {
                        "name": "Canada",
                        "color": "#1f77b4",
                        "color-stroke": "#3E5FFF"
                    },
                    "id": "CA"
                },
                ...
        }
    }
}
```

Then you can use the following `topoJSONLayer` configuration to display the layer in _LeafletMap_:
```ts
const topoJSONLayer = {
  sources: topojson,
  featureName: 'countries',
  fillProperty: 'color',
  strokeProperty: 'color-stroke',
}
```

<LeafletDoc
  height={400}
  topoJSONLayer={{
    sources: topojson,
    featureName: 'countries',
    fillProperty: 'color',
    strokeProperty: 'color-stroke',
  }}
/>

## Controlling the View
If you want the map to show a specific area upon initialization, you can set the `initialBounds` property in the
following format:

```ts
type Bounds = {
  northEast: { lat: number; lng: number };
  southWest: { lat: number; lng: number };
}
```
<LeafletDoc
  height={400}
  initialBounds={{
    northEast: { lat: 56, lng: 90 },
    southWest: { lat: 50, lng: 60 },
  }}
/>

Also, if you want to force set the map bounds, you can achieve that by setting the `bounds` config property.

## Map Callbacks
_LeafletMap_ has several configurable callback functions that will be called upon various map interactions:
`onMapInitialized`, `onMapMoveZoom`, `onMapMoveStart`, `onMapMoveEnd`, `onMapZoomStart`, `onMapZoomEnd` and `onMapClick`.
All of these functions (except `onMapInitialized`) will have `{ mapCenter, zoomLevel, bounds }` provided as an argument.

## Dark Theme
You can provide a separate style for the dark theme via the `styleDarkTheme` property, if you want _LeafletMap_ to
change its look when the dark theme is enabled.

## Tooltip
<LeafletDoc
  height={400}
  tooltip={tooltip}
  declarations={{
    ...defaultProps().declarations,
    tooltip: `new Tooltip({
    triggers: {
      [LeafletMap.selectors.mapboxglCanvas]: (features) => {
        const name = features[0]?.properties?.name ?? ''
        return \`<span>\${name}</span>\`
      },
    },
  })`}}
  hiddenProps={{
    ...defaultProps().hiddenProps,
    topoJSONLayer: {
      sources: topojson,
      featureName: 'countries',
      fillProperty: 'color',
      strokeProperty: 'color-stroke',
    }
  }}
  showContext={ContextLevel.Minimal}
  imports={{ '@volterra/vis': ['Tooltip', "LeafletMap"]}}
/>

## Events
The following selectors are available for events:
```ts
import { LeafletMap } from '@volterra/vis'
...
events = {
    [LeafletMap.selectors.point]: {},
    [LeafletMap.selectors.background]: {},
    [LeafletMap.selectors.innerLabel]: {},
    [LeafletMap.selectors.bottomLabel]: {},
    [LeafletMap.selectors.mapboxglCanvas]: {}
}
```

## Component Props
<PropTable name="VisLeafletMap"/>
