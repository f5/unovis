import BrowserOnly from '@docusaurus/BrowserOnly'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'
import CodeBlock from '@theme/CodeBlock'
import { XYDocTabs, XYWrapperWithInput, XYCompositeDoc, DynamicXYWrapper, XYWrapper } from '../components'
import { parseProps, parseXYConfig, getPropStrings } from '../utils/props-helper.ts'
import { PropTable } from '../utils/props-table.tsx'
import { generateDataRecords } from '../utils/data'

export const childProps = (chartName) => ({
  name: chartName,
  props: {
    x: d=>d.x, y: d=>d.y
  },
  key: "components"
});

export const defaultProps = (chartName="StackedBar", n=10) => ({
  data: generateDataRecords(n),
  height: 150,
  componentProps: [
    childProps(chartName),
    { name: 'Axis', props: { type: 'x'}, key: "xAxis"},
    { name: 'Axis', props: { type: 'y' }, key: "yAxis"},
  ]
})

export const ContainerTabs = (containerProps) => {
  const { componentStrings, contextProps } = getPropStrings(containerProps, true)
  return (
    <Tabs groupId="framework">
      <TabItem value="react" label="React">
        <CodeBlock language="jsx">
          {['function Component(props) {',
          '  const data: DataRecord[] = props.data',
           ...contextProps.map((p) => `  const ${p}`),
          '  return (',
          `    <VisXYContainer data={data} ${componentStrings.react}>`,
          '      {/* your vis components here */}',
          '    </VisXYContainer>',
          '  )', '};'].join('\n')}
        </CodeBlock>
      </TabItem>
      <TabItem value="angular" label="Angular">
        <CodeBlock language="ts">
          {['@Input() dataArray: DataRecord[]', ...contextProps].join('\n')}
        </CodeBlock>
        <CodeBlock language="html">
          {[`<vis-xy-container [data]="dataArray" ${componentStrings.angular}>`,
            '  <!-- your vis components here -->',
            '</vis-xy-container>'].join('\n')}
        </CodeBlock>
      </TabItem>
      <TabItem value="typescript" label="TypeScript">
        <CodeBlock language="ts">
          {['const config: XYContainerConfigInterface<DataRecord> = {',
            '  components: [/* your vis components here */]',
            contextProps.length ? [...contextProps.map(p => `  ${p.replace(' =', ':')},`)] :
            `  ${componentStrings.typescript}`,
            '}',
            'const chart = new XYContainer(containerNode, config, data)'].join('\n')}
        </CodeBlock>
      </TabItem>
    </Tabs>
  )
}

export const XYContainerDoc = ({ data, componentProps, tabMode="simple", height, ...rest }) => {
  return (
  <div>
    {tabMode === 'full' && <XYDocTabs {...parseXYConfig(componentProps)} showContext/>}
    {tabMode === 'simple' && <ContainerTabs { ...rest}/>}
    <XYCompositeDoc
    containerProps={{data, height, ...rest}}
    componentProps={componentProps}/>
  </div>
)}


### Basic configuration
The _Container_ component is designed as a wrapper to hold other vis elements. Here is an example of a common configuration: one _XYChart_ alongside two _Axis_ components:
<XYContainerDoc {...defaultProps()} tabMode="full" />

### Margin
You can change a _Container_ margins using the margin property, which accepts an object with the properties `top`, `bottom`, `left`, and `right` with corresponding pixel values.
This determines the distance between the XY container and other elements on the page. Notice what happens when each margin is set to `100px` and there is another element on the page.

export const MarginDoc = () => (
    <BrowserOnly fallback={<div>Loading...</div>}>
      {() => {
        // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-var-requires
        const { VisXYContainer, VisStackedBar, VisAxis } = require('@volterra/vis-react')
        return (
          <div style={{display: "flex", alignItems: "center", justifyContent: "center"}}>
          <p style={{backgroundColor: "gray", color: "white"}}>Left</p>
          <VisXYContainer
            data={generateDataRecords()}
            margin={{ top: 100, bottom: 100, right: 100, left: 200}}
          >
            <VisStackedBar x={d => d.x} y={d => d.y}/>
            <VisAxis type="y" gridLine={false} />
            <VisAxis type="x" gridLine={false} ticks={10}/>
          </VisXYContainer>
          <p style={{backgroundColor: "gray", color: "white"}}>Right</p>
          </div>
        )
      }}
    </BrowserOnly>
    )

<ContainerTabs margin={{ top: 100, bottom: 100, right: 100, left: 100}}/>
<MarginDoc/>

### Padding
Similarly, provide `padding` with the same object type to change a _Container_ component's padding (i.e. the space between the inner components).
<XYContainerDoc {...defaultProps()} padding={{ top: 100, bottom: 100, right: 100, left: 100}}/>

## Range
Change the range of screen space occupied by each dimension of your data using the `xRange` and `yRange` properties.
It accepts type `[number, number]` where the elements represent the starting and ending positions, respectively.

### xRange
Provide `xRange` with values [`xStart`, `width`]. More specifically, xStart is the offset relative to the starting position of the data.
<XYContainerDoc {...defaultProps()} xRange={[10,500]}/>

### yRange
<XYContainerDoc {...defaultProps()} yRange={[150,50]}/>

## Domain
You can change the domain of your data with the `xDomain` and `yDomain` properties to configure which values your `XYChart` should display.
The result will show all data that is in this range- excluding any values that fall outside of the range, and occupying any missing values with white space.
Consider the following examples where the actual data contains values in the domain `[0,10]` for `x` and `y`

### XDomain
<XYContainerDoc {...defaultProps()} xDomain={[4,8]}/>

### yDomain
<XYContainerDoc {...defaultProps()} yDomain={[4,8]}/>

### Domain Constraints
Customizing your domain is helpful in datasets with outliers. When using dynamic data, you may not know which values to constrain your domain values to.
With the following constraint properties `xDomainMinConstraint`, `xDomainMaxConstraint`, `yDomainMinConstraint`, and `yDomainMaxConstraint`, you can define partial domains.
For the following examples, consider the following case where the majority of the data is within the ranges `[0,10]` for all values of x and y.

These properties accept a number array in the form `[number, number]` or more typically `[number, undefined]` | `[undefined, number]`.

export const constraintData = generateDataRecords().map(d => ({ x: d.x + 1, y: d.y + 1})).concat([{ x: -5, y: -5}, { x: 15, y: 15}, { x: -5, y: 15}, {x: 15, y: -5 }])

#### Domain Constraints: None
<XYContainerDoc {...defaultProps("Scatter")} data={constraintData} tabMode={null}/>

#### xDomainMinConstraint
export const ConstraintDoc = ({options}) => (
  <Tabs groupId="constraint" className="prop-preview-menu">
    {options.map((d) => (
      <TabItem key={d.prop} value={d.prop} label={d.prop}>
        <CodeBlock language="ts">
          {`const ${d.prop} = [${d.value[0] || "undefined"}, ${d.value[1] || "undefined"}]`}
        </CodeBlock>
        <XYContainerDoc {...defaultProps("Scatter")} data={constraintData} tabMode={null} {...{ [d.prop]: d.value}}/>
      </TabItem>
    ))}
  </Tabs>
)

<ConstraintDoc options={[
  {prop: 'xDomainMinConstraint', value: [1,undefined]},
  {prop: 'yDomainMinConstraint', value: [1,undefined]},
  {prop: 'xDomainMaxConstraint', value: [undefined, 10]},
  {prop: 'yDomainMaxConstraint', value: [undefined, 10]}
]}/>

## Scale
To change the scale of one of your axes in your _Container_, use the `xScale` or `yScale` property and a Scale function (i.e. `Scale.scaleLinear()`).
Currently, only continuous scales are supported. See d3-scale for more information about the meaning behind these functions.

export const ScaleDoc = ({x,y}) => {
  const [scale, setScale] = React.useState("scaleLinear")
  const scaleDeclaration = [`${x ? 'x' : 'y'}Scale`, `Scale.${scale}()`];     
  return (
  <BrowserOnly fallback={<div>Loading...</div>}>
      {() => {
        // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-var-requires
        const { VisXYContainer, VisScatter, VisLine, VisAxis } = require('@volterra/vis-react')
        const { Scale } = require('@volterra/vis')
        const scaleProp = () => x ? { xScale: Scale[scale]()} : { yScale: Scale[scale]()}
        return (
          <>
          <div style={{display: "flex", justifyContent: "center"}}>
          <label style={{marginRight: '1em'}}>{`${x ? "x" : "y"}Scale:`}</label>
          <select value={scale} onChange={e => setScale(e.target.value)}>
            {Object.keys(Scale).map(k => <option key={k} value={k} >{k}</option>)}
          </select>
          </div>
           <Tabs groupId="framework">
            <TabItem value="react" label="React">
              <CodeBlock language="jsx">
                {['import { Scale } from "@volterra/vis"','',
                  'function Component(props) {',
                '  const data: DataRecord[] = props.data',
                '',
                '  return (',
                `    <VisXYContainer data={data} ${scaleDeclaration.join('={')}}>`,
                '      {/* your vis components here */}',
                '    </VisXYContainer>',
                '  )', '};'].join('\n')}
              </CodeBlock>
            </TabItem>
            <TabItem value="angular" label="Angular">
              <CodeBlock language="ts">
                {['import { Scale } from "@volterra/vis"','',
                  '@Component({...})',
                  'class Component {',
                  '  @Input() dataArray: DataRecord[]',
                  `  scale = ${scaleDeclaration[1]}`, '};'].join('\n')}
              </CodeBlock>
              <CodeBlock language="html">
                {[`<vis-xy-container [data]="dataArray"  [${scaleDeclaration[0]}]="scale">`,
                  '  <!-- your vis components here -->',
                  '</vis-xy-container>'].join('\n')}
              </CodeBlock>
            </TabItem>
            <TabItem value="typescript" label="TypeScript">
              <CodeBlock language="ts">
                {['import { Scale } from "@volterra/vis"','',
                  'const config: XYContainerConfigInterface<DataRecord> = {',
                  '  components: [/* your vis components here */]',
                  `  ${scaleDeclaration.join(': ')}`,
                  '}',
                  'const chart = new XYContainer(containerNode, config, data)'].join('\n')}
              </CodeBlock>
            </TabItem>
          </Tabs>
           <VisXYContainer height={200} data={Array(50).fill(0).map((d,i) => ({ x: i, y: i}))} {...scaleProp()} margin={{left: 200, right: 200}}>
             <VisLine x={d=>d.x} y={d=>d.y}/>
              <VisScatter x={d=>d.x} y={d=>d.y} sizeRange={[2,10]}/>
              <VisAxis type="x"/>
              <VisAxis type="y"/>
            </VisXYContainer>
          </>
        )
      }}
    </BrowserOnly>
  );
  }

### xScale
<ScaleDoc x/>

### yScale
<ScaleDoc y/>

export const dynamicData = generateDataRecords(150).map(d => ({...d, y: Math.abs(Math.cos(d.x/(10*Math.PI)))*d.x}))

### scaleByDomain
You can also set the `yScale` domain dynamically based on the current `xDomain`, meaning that only visible data will be used in the domain calculation.
Take a look at the example below. The `xDomain` configuration property there is not set, the chart displays the whole dataset and the Y axis shows ticks from 0 to 150.

<XYContainerDoc {...defaultProps("StackedBar")} data={dynamicData}/>

Let's set `xDomain` to `[0, 50]`. The chart now shows only a portion of the original data but the Y axis still displays the whole data range.
Setting `scaleByDomain` to `true` will tell the chart to dynamically calculate the domain of `yScale` based on the data within `xDomain`.
It comes in hand when you're updating xDomain programmatically using, for example, the _Brush_ component to provide some navigation capabilities to a chart with lots of data points.

```ts
const xDomain = [0,50]
```
<XYWrapperWithInput {...defaultProps("StackedBar")} name="XYContainer" data={dynamicData} xDomain={[0,50]} property="scaleByDomain" defaultValue={true} inputType="checkbox"/>

<PropTable name="VisXYContainer"/>

